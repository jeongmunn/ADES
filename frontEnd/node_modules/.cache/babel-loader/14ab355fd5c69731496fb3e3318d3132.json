{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/jw/OneDrive/Documents/GitHub/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/jw/OneDrive/Documents/GitHub/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nvar messages_1 = require(\"./messages\");\n\nvar buffer_reader_1 = require(\"./buffer-reader\");\n\nvar assert_1 = __importDefault(require(\"assert\")); // every message is prefixed with a single bye\n\n\nvar CODE_LENGTH = 1; // every message has an int32 length which includes itself but does\n// NOT include the code in the length\n\nvar LEN_LENGTH = 4;\nvar HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nvar emptyBuffer = Buffer.allocUnsafe(0);\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(opts) {\n    _classCallCheck(this, Parser);\n\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(buffer, callback) {\n      this.mergeBuffer(buffer);\n      var bufferFullLength = this.bufferOffset + this.bufferLength;\n      var offset = this.bufferOffset;\n\n      while (offset + HEADER_LENGTH <= bufferFullLength) {\n        // code is 1 byte long - it identifies the message type\n        var code = this.buffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n\n        var length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n        var fullMessageLength = CODE_LENGTH + length;\n\n        if (fullMessageLength + offset <= bufferFullLength) {\n          var message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n          callback(message);\n          offset += fullMessageLength;\n        } else {\n          break;\n        }\n      }\n\n      if (offset === bufferFullLength) {\n        // No more use for the buffer\n        this.buffer = emptyBuffer;\n        this.bufferLength = 0;\n        this.bufferOffset = 0;\n      } else {\n        // Adjust the cursors of remainingBuffer\n        this.bufferLength = bufferFullLength - offset;\n        this.bufferOffset = offset;\n      }\n    }\n  }, {\n    key: \"mergeBuffer\",\n    value: function mergeBuffer(buffer) {\n      if (this.bufferLength > 0) {\n        var newLength = this.bufferLength + buffer.byteLength;\n        var newFullLength = newLength + this.bufferOffset;\n\n        if (newFullLength > this.buffer.byteLength) {\n          // We can't concat the new buffer with the remaining one\n          var newBuffer;\n\n          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n            // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n            newBuffer = this.buffer;\n          } else {\n            // Allocate a new larger buffer\n            var newBufferLength = this.buffer.byteLength * 2;\n\n            while (newLength >= newBufferLength) {\n              newBufferLength *= 2;\n            }\n\n            newBuffer = Buffer.allocUnsafe(newBufferLength);\n          } // Move the remaining buffer to the new one\n\n\n          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n          this.buffer = newBuffer;\n          this.bufferOffset = 0;\n        } // Concat the new buffer with the remaining one\n\n\n        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n        this.bufferLength = newLength;\n      } else {\n        this.buffer = buffer;\n        this.bufferOffset = 0;\n        this.bufferLength = buffer.byteLength;\n      }\n    }\n  }, {\n    key: \"handlePacket\",\n    value: function handlePacket(offset, code, length, bytes) {\n      switch (code) {\n        case 50\n        /* BindComplete */\n        :\n          return messages_1.bindComplete;\n\n        case 49\n        /* ParseComplete */\n        :\n          return messages_1.parseComplete;\n\n        case 51\n        /* CloseComplete */\n        :\n          return messages_1.closeComplete;\n\n        case 110\n        /* NoData */\n        :\n          return messages_1.noData;\n\n        case 115\n        /* PortalSuspended */\n        :\n          return messages_1.portalSuspended;\n\n        case 99\n        /* CopyDone */\n        :\n          return messages_1.copyDone;\n\n        case 87\n        /* ReplicationStart */\n        :\n          return messages_1.replicationStart;\n\n        case 73\n        /* EmptyQuery */\n        :\n          return messages_1.emptyQuery;\n\n        case 68\n        /* DataRow */\n        :\n          return this.parseDataRowMessage(offset, length, bytes);\n\n        case 67\n        /* CommandComplete */\n        :\n          return this.parseCommandCompleteMessage(offset, length, bytes);\n\n        case 90\n        /* ReadyForQuery */\n        :\n          return this.parseReadyForQueryMessage(offset, length, bytes);\n\n        case 65\n        /* NotificationResponse */\n        :\n          return this.parseNotificationMessage(offset, length, bytes);\n\n        case 82\n        /* AuthenticationResponse */\n        :\n          return this.parseAuthenticationResponse(offset, length, bytes);\n\n        case 83\n        /* ParameterStatus */\n        :\n          return this.parseParameterStatusMessage(offset, length, bytes);\n\n        case 75\n        /* BackendKeyData */\n        :\n          return this.parseBackendKeyData(offset, length, bytes);\n\n        case 69\n        /* ErrorMessage */\n        :\n          return this.parseErrorMessage(offset, length, bytes, 'error');\n\n        case 78\n        /* NoticeMessage */\n        :\n          return this.parseErrorMessage(offset, length, bytes, 'notice');\n\n        case 84\n        /* RowDescriptionMessage */\n        :\n          return this.parseRowDescriptionMessage(offset, length, bytes);\n\n        case 116\n        /* ParameterDescriptionMessage */\n        :\n          return this.parseParameterDescriptionMessage(offset, length, bytes);\n\n        case 71\n        /* CopyIn */\n        :\n          return this.parseCopyInMessage(offset, length, bytes);\n\n        case 72\n        /* CopyOut */\n        :\n          return this.parseCopyOutMessage(offset, length, bytes);\n\n        case 100\n        /* CopyData */\n        :\n          return this.parseCopyData(offset, length, bytes);\n\n        default:\n          assert_1.default.fail(\"unknown message code: \".concat(code.toString(16)));\n      }\n    }\n  }, {\n    key: \"parseReadyForQueryMessage\",\n    value: function parseReadyForQueryMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var status = this.reader.string(1);\n      return new messages_1.ReadyForQueryMessage(length, status);\n    }\n  }, {\n    key: \"parseCommandCompleteMessage\",\n    value: function parseCommandCompleteMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var text = this.reader.cstring();\n      return new messages_1.CommandCompleteMessage(length, text);\n    }\n  }, {\n    key: \"parseCopyData\",\n    value: function parseCopyData(offset, length, bytes) {\n      var chunk = bytes.slice(offset, offset + (length - 4));\n      return new messages_1.CopyDataMessage(length, chunk);\n    }\n  }, {\n    key: \"parseCopyInMessage\",\n    value: function parseCopyInMessage(offset, length, bytes) {\n      return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n    }\n  }, {\n    key: \"parseCopyOutMessage\",\n    value: function parseCopyOutMessage(offset, length, bytes) {\n      return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n    }\n  }, {\n    key: \"parseCopyMessage\",\n    value: function parseCopyMessage(offset, length, bytes, messageName) {\n      this.reader.setBuffer(offset, bytes);\n      var isBinary = this.reader.byte() !== 0;\n      var columnCount = this.reader.int16();\n      var message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n\n      for (var i = 0; i < columnCount; i++) {\n        message.columnTypes[i] = this.reader.int16();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseNotificationMessage\",\n    value: function parseNotificationMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var processId = this.reader.int32();\n      var channel = this.reader.cstring();\n      var payload = this.reader.cstring();\n      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n    }\n  }, {\n    key: \"parseRowDescriptionMessage\",\n    value: function parseRowDescriptionMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var fieldCount = this.reader.int16();\n      var message = new messages_1.RowDescriptionMessage(length, fieldCount);\n\n      for (var i = 0; i < fieldCount; i++) {\n        message.fields[i] = this.parseField();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseField\",\n    value: function parseField() {\n      var name = this.reader.cstring();\n      var tableID = this.reader.int32();\n      var columnID = this.reader.int16();\n      var dataTypeID = this.reader.int32();\n      var dataTypeSize = this.reader.int16();\n      var dataTypeModifier = this.reader.int32();\n      var mode = this.reader.int16() === 0 ? 'text' : 'binary';\n      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n  }, {\n    key: \"parseParameterDescriptionMessage\",\n    value: function parseParameterDescriptionMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var parameterCount = this.reader.int16();\n      var message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n\n      for (var i = 0; i < parameterCount; i++) {\n        message.dataTypeIDs[i] = this.reader.int32();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseDataRowMessage\",\n    value: function parseDataRowMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var fieldCount = this.reader.int16();\n      var fields = new Array(fieldCount);\n\n      for (var i = 0; i < fieldCount; i++) {\n        var len = this.reader.int32(); // a -1 for length means the value of the field is null\n\n        fields[i] = len === -1 ? null : this.reader.string(len);\n      }\n\n      return new messages_1.DataRowMessage(length, fields);\n    }\n  }, {\n    key: \"parseParameterStatusMessage\",\n    value: function parseParameterStatusMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var name = this.reader.cstring();\n      var value = this.reader.cstring();\n      return new messages_1.ParameterStatusMessage(length, name, value);\n    }\n  }, {\n    key: \"parseBackendKeyData\",\n    value: function parseBackendKeyData(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var processID = this.reader.int32();\n      var secretKey = this.reader.int32();\n      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n    }\n  }, {\n    key: \"parseAuthenticationResponse\",\n    value: function parseAuthenticationResponse(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var code = this.reader.int32(); // TODO(bmc): maybe better types here\n\n      var message = {\n        name: 'authenticationOk',\n        length: length\n      };\n\n      switch (code) {\n        case 0:\n          // AuthenticationOk\n          break;\n\n        case 3:\n          // AuthenticationCleartextPassword\n          if (message.length === 8) {\n            message.name = 'authenticationCleartextPassword';\n          }\n\n          break;\n\n        case 5:\n          // AuthenticationMD5Password\n          if (message.length === 12) {\n            message.name = 'authenticationMD5Password';\n            var salt = this.reader.bytes(4);\n            return new messages_1.AuthenticationMD5Password(length, salt);\n          }\n\n          break;\n\n        case 10:\n          // AuthenticationSASL\n          message.name = 'authenticationSASL';\n          message.mechanisms = [];\n          var mechanism;\n\n          do {\n            mechanism = this.reader.cstring();\n\n            if (mechanism) {\n              message.mechanisms.push(mechanism);\n            }\n          } while (mechanism);\n\n          break;\n\n        case 11:\n          // AuthenticationSASLContinue\n          message.name = 'authenticationSASLContinue';\n          message.data = this.reader.string(length - 8);\n          break;\n\n        case 12:\n          // AuthenticationSASLFinal\n          message.name = 'authenticationSASLFinal';\n          message.data = this.reader.string(length - 8);\n          break;\n\n        default:\n          throw new Error('Unknown authenticationOk message type ' + code);\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseErrorMessage\",\n    value: function parseErrorMessage(offset, length, bytes, name) {\n      this.reader.setBuffer(offset, bytes);\n      var fields = {};\n      var fieldType = this.reader.string(1);\n\n      while (fieldType !== '\\0') {\n        fields[fieldType] = this.reader.cstring();\n        fieldType = this.reader.string(1);\n      }\n\n      var messageValue = fields.M;\n      var message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n      message.severity = fields.S;\n      message.code = fields.C;\n      message.detail = fields.D;\n      message.hint = fields.H;\n      message.position = fields.P;\n      message.internalPosition = fields.p;\n      message.internalQuery = fields.q;\n      message.where = fields.W;\n      message.schema = fields.s;\n      message.table = fields.t;\n      message.column = fields.c;\n      message.dataType = fields.d;\n      message.constraint = fields.n;\n      message.file = fields.F;\n      message.line = fields.L;\n      message.routine = fields.R;\n      return message;\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.Parser = Parser;","map":{"version":3,"sources":["../src/parser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AA2BA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA,C,CAEA;;;AACA,IAAM,WAAW,GAAG,CAApB,C,CACA;AACA;;AACA,IAAM,UAAU,GAAG,CAAnB;AAEA,IAAM,aAAa,GAAG,WAAW,GAAG,UAApC;AAOA,IAAM,WAAW,GAAG,MAAM,CAAC,WAAP,CAAmB,CAAnB,CAApB;;IAiCa,M;AAOX,kBAAY,IAAZ,EAAgC;AAAA;;AANxB,SAAA,MAAA,GAAiB,WAAjB;AACA,SAAA,YAAA,GAAuB,CAAvB;AACA,SAAA,YAAA,GAAuB,CAAvB;AACA,SAAA,MAAA,GAAS,IAAI,eAAA,CAAA,YAAJ,EAAT;;AAIN,QAAI,CAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,IAAN,MAAe,QAAnB,EAA6B;AAC3B,YAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACD;;AACD,SAAK,IAAL,GAAY,CAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,IAAN,KAAc,MAA1B;AACD;;;;WAEM,eAAM,MAAN,EAAsB,QAAtB,EAA+C;AACpD,WAAK,WAAL,CAAiB,MAAjB;AACA,UAAM,gBAAgB,GAAG,KAAK,YAAL,GAAoB,KAAK,YAAlD;AACA,UAAI,MAAM,GAAG,KAAK,YAAlB;;AACA,aAAO,MAAM,GAAG,aAAT,IAA0B,gBAAjC,EAAmD;AACjD;AACA,YAAM,IAAI,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAb,CAFiD,CAGjD;;AACA,YAAM,MAAM,GAAG,KAAK,MAAL,CAAY,YAAZ,CAAyB,MAAM,GAAG,WAAlC,CAAf;AACA,YAAM,iBAAiB,GAAG,WAAW,GAAG,MAAxC;;AACA,YAAI,iBAAiB,GAAG,MAApB,IAA8B,gBAAlC,EAAoD;AAClD,cAAM,OAAO,GAAG,KAAK,YAAL,CAAkB,MAAM,GAAG,aAA3B,EAA0C,IAA1C,EAAgD,MAAhD,EAAwD,KAAK,MAA7D,CAAhB;AACA,UAAA,QAAQ,CAAC,OAAD,CAAR;AACA,UAAA,MAAM,IAAI,iBAAV;AACD,SAJD,MAIO;AACL;AACD;AACF;;AACD,UAAI,MAAM,KAAK,gBAAf,EAAiC;AAC/B;AACA,aAAK,MAAL,GAAc,WAAd;AACA,aAAK,YAAL,GAAoB,CAApB;AACA,aAAK,YAAL,GAAoB,CAApB;AACD,OALD,MAKO;AACL;AACA,aAAK,YAAL,GAAoB,gBAAgB,GAAG,MAAvC;AACA,aAAK,YAAL,GAAoB,MAApB;AACD;AACF;;;WAEO,qBAAY,MAAZ,EAA0B;AAChC,UAAI,KAAK,YAAL,GAAoB,CAAxB,EAA2B;AACzB,YAAM,SAAS,GAAG,KAAK,YAAL,GAAoB,MAAM,CAAC,UAA7C;AACA,YAAM,aAAa,GAAG,SAAS,GAAG,KAAK,YAAvC;;AACA,YAAI,aAAa,GAAG,KAAK,MAAL,CAAY,UAAhC,EAA4C;AAC1C;AACA,cAAI,SAAJ;;AACA,cAAI,SAAS,IAAI,KAAK,MAAL,CAAY,UAAzB,IAAuC,KAAK,YAAL,IAAqB,KAAK,YAArE,EAAmF;AACjF;AACA,YAAA,SAAS,GAAG,KAAK,MAAjB;AACD,WAHD,MAGO;AACL;AACA,gBAAI,eAAe,GAAG,KAAK,MAAL,CAAY,UAAZ,GAAyB,CAA/C;;AACA,mBAAO,SAAS,IAAI,eAApB,EAAqC;AACnC,cAAA,eAAe,IAAI,CAAnB;AACD;;AACD,YAAA,SAAS,GAAG,MAAM,CAAC,WAAP,CAAmB,eAAnB,CAAZ;AACD,WAbyC,CAc1C;;;AACA,eAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB,EAA4B,CAA5B,EAA+B,KAAK,YAApC,EAAkD,KAAK,YAAL,GAAoB,KAAK,YAA3E;AACA,eAAK,MAAL,GAAc,SAAd;AACA,eAAK,YAAL,GAAoB,CAApB;AACD,SArBwB,CAsBzB;;;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,KAAK,MAAjB,EAAyB,KAAK,YAAL,GAAoB,KAAK,YAAlD;AACA,aAAK,YAAL,GAAoB,SAApB;AACD,OAzBD,MAyBO;AACL,aAAK,MAAL,GAAc,MAAd;AACA,aAAK,YAAL,GAAoB,CAApB;AACA,aAAK,YAAL,GAAoB,MAAM,CAAC,UAA3B;AACD;AACF;;;WAEO,sBAAa,MAAb,EAA6B,IAA7B,EAA2C,MAA3C,EAA2D,KAA3D,EAAwE;AAC9E,cAAQ,IAAR;AACE,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,YAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,aAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,aAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,MAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,eAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,QAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,gBAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,UAAA,CAAA,UAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,mBAAL,CAAyB,MAAzB,EAAiC,MAAjC,EAAyC,KAAzC,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,2BAAL,CAAiC,MAAjC,EAAyC,MAAzC,EAAiD,KAAjD,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,yBAAL,CAA+B,MAA/B,EAAuC,MAAvC,EAA+C,KAA/C,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,wBAAL,CAA8B,MAA9B,EAAsC,MAAtC,EAA8C,KAA9C,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,2BAAL,CAAiC,MAAjC,EAAyC,MAAzC,EAAiD,KAAjD,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,2BAAL,CAAiC,MAAjC,EAAyC,MAAzC,EAAiD,KAAjD,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,mBAAL,CAAyB,MAAzB,EAAiC,MAAjC,EAAyC,KAAzC,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,iBAAL,CAAuB,MAAvB,EAA+B,MAA/B,EAAuC,KAAvC,EAA8C,OAA9C,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,iBAAL,CAAuB,MAAvB,EAA+B,MAA/B,EAAuC,KAAvC,EAA8C,QAA9C,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,0BAAL,CAAgC,MAAhC,EAAwC,MAAxC,EAAgD,KAAhD,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,gCAAL,CAAsC,MAAtC,EAA8C,MAA9C,EAAsD,KAAtD,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,kBAAL,CAAwB,MAAxB,EAAgC,MAAhC,EAAwC,KAAxC,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,mBAAL,CAAyB,MAAzB,EAAiC,MAAjC,EAAyC,KAAzC,CAAP;;AACF,aAAA;AAAA;AAAA;AACE,iBAAO,KAAK,aAAL,CAAmB,MAAnB,EAA2B,MAA3B,EAAmC,KAAnC,CAAP;;AACF;AACE,UAAA,QAAA,CAAA,OAAA,CAAO,IAAP,iCAAqC,IAAI,CAAC,QAAL,CAAc,EAAd,CAArC;AA9CJ;AAgDD;;;WAEO,mCAA0B,MAA1B,EAA0C,MAA1C,EAA0D,KAA1D,EAAuE;AAC7E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,MAAM,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,CAAnB,CAAf;AACA,aAAO,IAAI,UAAA,CAAA,oBAAJ,CAAyB,MAAzB,EAAiC,MAAjC,CAAP;AACD;;;WAEO,qCAA4B,MAA5B,EAA4C,MAA5C,EAA4D,KAA5D,EAAyE;AAC/E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAb;AACA,aAAO,IAAI,UAAA,CAAA,sBAAJ,CAA2B,MAA3B,EAAmC,IAAnC,CAAP;AACD;;;WAEO,uBAAc,MAAd,EAA8B,MAA9B,EAA8C,KAA9C,EAA2D;AACjE,UAAM,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,MAAZ,EAAoB,MAAM,IAAI,MAAM,GAAG,CAAb,CAA1B,CAAd;AACA,aAAO,IAAI,UAAA,CAAA,eAAJ,CAAoB,MAApB,EAA4B,KAA5B,CAAP;AACD;;;WAEO,4BAAmB,MAAnB,EAAmC,MAAnC,EAAmD,KAAnD,EAAgE;AACtE,aAAO,KAAK,gBAAL,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,EAA6C,gBAA7C,CAAP;AACD;;;WAEO,6BAAoB,MAApB,EAAoC,MAApC,EAAoD,KAApD,EAAiE;AACvE,aAAO,KAAK,gBAAL,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,EAA6C,iBAA7C,CAAP;AACD;;;WAEO,0BAAiB,MAAjB,EAAiC,MAAjC,EAAiD,KAAjD,EAAgE,WAAhE,EAAwF;AAC9F,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,IAAZ,OAAuB,CAAxC;AACA,UAAM,WAAW,GAAG,KAAK,MAAL,CAAY,KAAZ,EAApB;AACA,UAAM,OAAO,GAAG,IAAI,UAAA,CAAA,YAAJ,CAAiB,MAAjB,EAAyB,WAAzB,EAAsC,QAAtC,EAAgD,WAAhD,CAAhB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,QAAA,OAAO,CAAC,WAAR,CAAoB,CAApB,IAAyB,KAAK,MAAL,CAAY,KAAZ,EAAzB;AACD;;AACD,aAAO,OAAP;AACD;;;WAEO,kCAAyB,MAAzB,EAAyC,MAAzC,EAAyD,KAAzD,EAAsE;AAC5E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAlB;AACA,UAAM,OAAO,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAhB;AACA,UAAM,OAAO,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAhB;AACA,aAAO,IAAI,UAAA,CAAA,2BAAJ,CAAgC,MAAhC,EAAwC,SAAxC,EAAmD,OAAnD,EAA4D,OAA5D,CAAP;AACD;;;WAEO,oCAA2B,MAA3B,EAA2C,MAA3C,EAA2D,KAA3D,EAAwE;AAC9E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,UAAU,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAnB;AACA,UAAM,OAAO,GAAG,IAAI,UAAA,CAAA,qBAAJ,CAA0B,MAA1B,EAAkC,UAAlC,CAAhB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,QAAA,OAAO,CAAC,MAAR,CAAe,CAAf,IAAoB,KAAK,UAAL,EAApB;AACD;;AACD,aAAO,OAAP;AACD;;;WAEO,sBAAU;AAChB,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAb;AACA,UAAM,OAAO,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAhB;AACA,UAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAjB;AACA,UAAM,UAAU,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAnB;AACA,UAAM,YAAY,GAAG,KAAK,MAAL,CAAY,KAAZ,EAArB;AACA,UAAM,gBAAgB,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAzB;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,KAAZ,OAAwB,CAAxB,GAA4B,MAA5B,GAAqC,QAAlD;AACA,aAAO,IAAI,UAAA,CAAA,KAAJ,CAAU,IAAV,EAAgB,OAAhB,EAAyB,QAAzB,EAAmC,UAAnC,EAA+C,YAA/C,EAA6D,gBAA7D,EAA+E,IAA/E,CAAP;AACD;;;WAEO,0CAAiC,MAAjC,EAAiD,MAAjD,EAAiE,KAAjE,EAA8E;AACpF,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,cAAc,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAvB;AACA,UAAM,OAAO,GAAG,IAAI,UAAA,CAAA,2BAAJ,CAAgC,MAAhC,EAAwC,cAAxC,CAAhB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACvC,QAAA,OAAO,CAAC,WAAR,CAAoB,CAApB,IAAyB,KAAK,MAAL,CAAY,KAAZ,EAAzB;AACD;;AACD,aAAO,OAAP;AACD;;;WAEO,6BAAoB,MAApB,EAAoC,MAApC,EAAoD,KAApD,EAAiE;AACvE,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,UAAU,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAnB;AACA,UAAM,MAAM,GAAU,IAAI,KAAJ,CAAU,UAAV,CAAtB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,YAAM,GAAG,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAZ,CADmC,CAEnC;;AACA,QAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAG,KAAK,CAAC,CAAT,GAAa,IAAb,GAAoB,KAAK,MAAL,CAAY,MAAZ,CAAmB,GAAnB,CAAhC;AACD;;AACD,aAAO,IAAI,UAAA,CAAA,cAAJ,CAAmB,MAAnB,EAA2B,MAA3B,CAAP;AACD;;;WAEO,qCAA4B,MAA5B,EAA4C,MAA5C,EAA4D,KAA5D,EAAyE;AAC/E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAb;AACA,UAAM,KAAK,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAd;AACA,aAAO,IAAI,UAAA,CAAA,sBAAJ,CAA2B,MAA3B,EAAmC,IAAnC,EAAyC,KAAzC,CAAP;AACD;;;WAEO,6BAAoB,MAApB,EAAoC,MAApC,EAAoD,KAApD,EAAiE;AACvE,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAlB;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAlB;AACA,aAAO,IAAI,UAAA,CAAA,qBAAJ,CAA0B,MAA1B,EAAkC,SAAlC,EAA6C,SAA7C,CAAP;AACD;;;WAEM,qCAA4B,MAA5B,EAA4C,MAA5C,EAA4D,KAA5D,EAAyE;AAC9E,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAb,CAF8E,CAG9E;;AACA,UAAM,OAAO,GAAyB;AACpC,QAAA,IAAI,EAAE,kBAD8B;AAEpC,QAAA,MAAM,EAAN;AAFoC,OAAtC;;AAKA,cAAQ,IAAR;AACE,aAAK,CAAL;AAAQ;AACN;;AACF,aAAK,CAAL;AAAQ;AACN,cAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACxB,YAAA,OAAO,CAAC,IAAR,GAAe,iCAAf;AACD;;AACD;;AACF,aAAK,CAAL;AAAQ;AACN,cAAI,OAAO,CAAC,MAAR,KAAmB,EAAvB,EAA2B;AACzB,YAAA,OAAO,CAAC,IAAR,GAAe,2BAAf;AACA,gBAAM,IAAI,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAkB,CAAlB,CAAb;AACA,mBAAO,IAAI,UAAA,CAAA,yBAAJ,CAA8B,MAA9B,EAAsC,IAAtC,CAAP;AACD;;AACD;;AACF,aAAK,EAAL;AAAS;AACP,UAAA,OAAO,CAAC,IAAR,GAAe,oBAAf;AACA,UAAA,OAAO,CAAC,UAAR,GAAqB,EAArB;AACA,cAAI,SAAJ;;AACA,aAAG;AACD,YAAA,SAAS,GAAG,KAAK,MAAL,CAAY,OAAZ,EAAZ;;AAEA,gBAAI,SAAJ,EAAe;AACb,cAAA,OAAO,CAAC,UAAR,CAAmB,IAAnB,CAAwB,SAAxB;AACD;AACF,WAND,QAMS,SANT;;AAOA;;AACF,aAAK,EAAL;AAAS;AACP,UAAA,OAAO,CAAC,IAAR,GAAe,4BAAf;AACA,UAAA,OAAO,CAAC,IAAR,GAAe,KAAK,MAAL,CAAY,MAAZ,CAAmB,MAAM,GAAG,CAA5B,CAAf;AACA;;AACF,aAAK,EAAL;AAAS;AACP,UAAA,OAAO,CAAC,IAAR,GAAe,yBAAf;AACA,UAAA,OAAO,CAAC,IAAR,GAAe,KAAK,MAAL,CAAY,MAAZ,CAAmB,MAAM,GAAG,CAA5B,CAAf;AACA;;AACF;AACE,gBAAM,IAAI,KAAJ,CAAU,2CAA2C,IAArD,CAAN;AApCJ;;AAsCA,aAAO,OAAP;AACD;;;WAEO,2BAAkB,MAAlB,EAAkC,MAAlC,EAAkD,KAAlD,EAAiE,IAAjE,EAAkF;AACxF,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB,EAA8B,KAA9B;AACA,UAAM,MAAM,GAA2B,EAAvC;AACA,UAAI,SAAS,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,CAAnB,CAAhB;;AACA,aAAO,SAAS,KAAK,IAArB,EAA2B;AACzB,QAAA,MAAM,CAAC,SAAD,CAAN,GAAoB,KAAK,MAAL,CAAY,OAAZ,EAApB;AACA,QAAA,SAAS,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,CAAnB,CAAZ;AACD;;AAED,UAAM,YAAY,GAAG,MAAM,CAAC,CAA5B;AAEA,UAAM,OAAO,GACX,IAAI,KAAK,QAAT,GAAoB,IAAI,UAAA,CAAA,aAAJ,CAAkB,MAAlB,EAA0B,YAA1B,CAApB,GAA8D,IAAI,UAAA,CAAA,aAAJ,CAAkB,YAAlB,EAAgC,MAAhC,EAAwC,IAAxC,CADhE;AAGA,MAAA,OAAO,CAAC,QAAR,GAAmB,MAAM,CAAC,CAA1B;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,MAAM,CAAC,CAAtB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAM,CAAC,CAAxB;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,MAAM,CAAC,CAAtB;AACA,MAAA,OAAO,CAAC,QAAR,GAAmB,MAAM,CAAC,CAA1B;AACA,MAAA,OAAO,CAAC,gBAAR,GAA2B,MAAM,CAAC,CAAlC;AACA,MAAA,OAAO,CAAC,aAAR,GAAwB,MAAM,CAAC,CAA/B;AACA,MAAA,OAAO,CAAC,KAAR,GAAgB,MAAM,CAAC,CAAvB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAM,CAAC,CAAxB;AACA,MAAA,OAAO,CAAC,KAAR,GAAgB,MAAM,CAAC,CAAvB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAM,CAAC,CAAxB;AACA,MAAA,OAAO,CAAC,QAAR,GAAmB,MAAM,CAAC,CAA1B;AACA,MAAA,OAAO,CAAC,UAAR,GAAqB,MAAM,CAAC,CAA5B;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,MAAM,CAAC,CAAtB;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,MAAM,CAAC,CAAtB;AACA,MAAA,OAAO,CAAC,OAAR,GAAkB,MAAM,CAAC,CAAzB;AACA,aAAO,OAAP;AACD;;;;;;AAtTH,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Parser = void 0;\r\nconst messages_1 = require(\"./messages\");\r\nconst buffer_reader_1 = require(\"./buffer-reader\");\r\nconst assert_1 = __importDefault(require(\"assert\"));\r\n// every message is prefixed with a single bye\r\nconst CODE_LENGTH = 1;\r\n// every message has an int32 length which includes itself but does\r\n// NOT include the code in the length\r\nconst LEN_LENGTH = 4;\r\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\r\nconst emptyBuffer = Buffer.allocUnsafe(0);\r\nclass Parser {\r\n    constructor(opts) {\r\n        this.buffer = emptyBuffer;\r\n        this.bufferLength = 0;\r\n        this.bufferOffset = 0;\r\n        this.reader = new buffer_reader_1.BufferReader();\r\n        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\r\n            throw new Error('Binary mode not supported yet');\r\n        }\r\n        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\r\n    }\r\n    parse(buffer, callback) {\r\n        this.mergeBuffer(buffer);\r\n        const bufferFullLength = this.bufferOffset + this.bufferLength;\r\n        let offset = this.bufferOffset;\r\n        while (offset + HEADER_LENGTH <= bufferFullLength) {\r\n            // code is 1 byte long - it identifies the message type\r\n            const code = this.buffer[offset];\r\n            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\r\n            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\r\n            const fullMessageLength = CODE_LENGTH + length;\r\n            if (fullMessageLength + offset <= bufferFullLength) {\r\n                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\r\n                callback(message);\r\n                offset += fullMessageLength;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (offset === bufferFullLength) {\r\n            // No more use for the buffer\r\n            this.buffer = emptyBuffer;\r\n            this.bufferLength = 0;\r\n            this.bufferOffset = 0;\r\n        }\r\n        else {\r\n            // Adjust the cursors of remainingBuffer\r\n            this.bufferLength = bufferFullLength - offset;\r\n            this.bufferOffset = offset;\r\n        }\r\n    }\r\n    mergeBuffer(buffer) {\r\n        if (this.bufferLength > 0) {\r\n            const newLength = this.bufferLength + buffer.byteLength;\r\n            const newFullLength = newLength + this.bufferOffset;\r\n            if (newFullLength > this.buffer.byteLength) {\r\n                // We can't concat the new buffer with the remaining one\r\n                let newBuffer;\r\n                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\r\n                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\r\n                    newBuffer = this.buffer;\r\n                }\r\n                else {\r\n                    // Allocate a new larger buffer\r\n                    let newBufferLength = this.buffer.byteLength * 2;\r\n                    while (newLength >= newBufferLength) {\r\n                        newBufferLength *= 2;\r\n                    }\r\n                    newBuffer = Buffer.allocUnsafe(newBufferLength);\r\n                }\r\n                // Move the remaining buffer to the new one\r\n                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\r\n                this.buffer = newBuffer;\r\n                this.bufferOffset = 0;\r\n            }\r\n            // Concat the new buffer with the remaining one\r\n            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\r\n            this.bufferLength = newLength;\r\n        }\r\n        else {\r\n            this.buffer = buffer;\r\n            this.bufferOffset = 0;\r\n            this.bufferLength = buffer.byteLength;\r\n        }\r\n    }\r\n    handlePacket(offset, code, length, bytes) {\r\n        switch (code) {\r\n            case 50 /* BindComplete */:\r\n                return messages_1.bindComplete;\r\n            case 49 /* ParseComplete */:\r\n                return messages_1.parseComplete;\r\n            case 51 /* CloseComplete */:\r\n                return messages_1.closeComplete;\r\n            case 110 /* NoData */:\r\n                return messages_1.noData;\r\n            case 115 /* PortalSuspended */:\r\n                return messages_1.portalSuspended;\r\n            case 99 /* CopyDone */:\r\n                return messages_1.copyDone;\r\n            case 87 /* ReplicationStart */:\r\n                return messages_1.replicationStart;\r\n            case 73 /* EmptyQuery */:\r\n                return messages_1.emptyQuery;\r\n            case 68 /* DataRow */:\r\n                return this.parseDataRowMessage(offset, length, bytes);\r\n            case 67 /* CommandComplete */:\r\n                return this.parseCommandCompleteMessage(offset, length, bytes);\r\n            case 90 /* ReadyForQuery */:\r\n                return this.parseReadyForQueryMessage(offset, length, bytes);\r\n            case 65 /* NotificationResponse */:\r\n                return this.parseNotificationMessage(offset, length, bytes);\r\n            case 82 /* AuthenticationResponse */:\r\n                return this.parseAuthenticationResponse(offset, length, bytes);\r\n            case 83 /* ParameterStatus */:\r\n                return this.parseParameterStatusMessage(offset, length, bytes);\r\n            case 75 /* BackendKeyData */:\r\n                return this.parseBackendKeyData(offset, length, bytes);\r\n            case 69 /* ErrorMessage */:\r\n                return this.parseErrorMessage(offset, length, bytes, 'error');\r\n            case 78 /* NoticeMessage */:\r\n                return this.parseErrorMessage(offset, length, bytes, 'notice');\r\n            case 84 /* RowDescriptionMessage */:\r\n                return this.parseRowDescriptionMessage(offset, length, bytes);\r\n            case 116 /* ParameterDescriptionMessage */:\r\n                return this.parseParameterDescriptionMessage(offset, length, bytes);\r\n            case 71 /* CopyIn */:\r\n                return this.parseCopyInMessage(offset, length, bytes);\r\n            case 72 /* CopyOut */:\r\n                return this.parseCopyOutMessage(offset, length, bytes);\r\n            case 100 /* CopyData */:\r\n                return this.parseCopyData(offset, length, bytes);\r\n            default:\r\n                assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\r\n        }\r\n    }\r\n    parseReadyForQueryMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const status = this.reader.string(1);\r\n        return new messages_1.ReadyForQueryMessage(length, status);\r\n    }\r\n    parseCommandCompleteMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const text = this.reader.cstring();\r\n        return new messages_1.CommandCompleteMessage(length, text);\r\n    }\r\n    parseCopyData(offset, length, bytes) {\r\n        const chunk = bytes.slice(offset, offset + (length - 4));\r\n        return new messages_1.CopyDataMessage(length, chunk);\r\n    }\r\n    parseCopyInMessage(offset, length, bytes) {\r\n        return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\r\n    }\r\n    parseCopyOutMessage(offset, length, bytes) {\r\n        return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\r\n    }\r\n    parseCopyMessage(offset, length, bytes, messageName) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const isBinary = this.reader.byte() !== 0;\r\n        const columnCount = this.reader.int16();\r\n        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\r\n        for (let i = 0; i < columnCount; i++) {\r\n            message.columnTypes[i] = this.reader.int16();\r\n        }\r\n        return message;\r\n    }\r\n    parseNotificationMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const processId = this.reader.int32();\r\n        const channel = this.reader.cstring();\r\n        const payload = this.reader.cstring();\r\n        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\r\n    }\r\n    parseRowDescriptionMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const fieldCount = this.reader.int16();\r\n        const message = new messages_1.RowDescriptionMessage(length, fieldCount);\r\n        for (let i = 0; i < fieldCount; i++) {\r\n            message.fields[i] = this.parseField();\r\n        }\r\n        return message;\r\n    }\r\n    parseField() {\r\n        const name = this.reader.cstring();\r\n        const tableID = this.reader.int32();\r\n        const columnID = this.reader.int16();\r\n        const dataTypeID = this.reader.int32();\r\n        const dataTypeSize = this.reader.int16();\r\n        const dataTypeModifier = this.reader.int32();\r\n        const mode = this.reader.int16() === 0 ? 'text' : 'binary';\r\n        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\r\n    }\r\n    parseParameterDescriptionMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const parameterCount = this.reader.int16();\r\n        const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\r\n        for (let i = 0; i < parameterCount; i++) {\r\n            message.dataTypeIDs[i] = this.reader.int32();\r\n        }\r\n        return message;\r\n    }\r\n    parseDataRowMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const fieldCount = this.reader.int16();\r\n        const fields = new Array(fieldCount);\r\n        for (let i = 0; i < fieldCount; i++) {\r\n            const len = this.reader.int32();\r\n            // a -1 for length means the value of the field is null\r\n            fields[i] = len === -1 ? null : this.reader.string(len);\r\n        }\r\n        return new messages_1.DataRowMessage(length, fields);\r\n    }\r\n    parseParameterStatusMessage(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const name = this.reader.cstring();\r\n        const value = this.reader.cstring();\r\n        return new messages_1.ParameterStatusMessage(length, name, value);\r\n    }\r\n    parseBackendKeyData(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const processID = this.reader.int32();\r\n        const secretKey = this.reader.int32();\r\n        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\r\n    }\r\n    parseAuthenticationResponse(offset, length, bytes) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const code = this.reader.int32();\r\n        // TODO(bmc): maybe better types here\r\n        const message = {\r\n            name: 'authenticationOk',\r\n            length,\r\n        };\r\n        switch (code) {\r\n            case 0: // AuthenticationOk\r\n                break;\r\n            case 3: // AuthenticationCleartextPassword\r\n                if (message.length === 8) {\r\n                    message.name = 'authenticationCleartextPassword';\r\n                }\r\n                break;\r\n            case 5: // AuthenticationMD5Password\r\n                if (message.length === 12) {\r\n                    message.name = 'authenticationMD5Password';\r\n                    const salt = this.reader.bytes(4);\r\n                    return new messages_1.AuthenticationMD5Password(length, salt);\r\n                }\r\n                break;\r\n            case 10: // AuthenticationSASL\r\n                message.name = 'authenticationSASL';\r\n                message.mechanisms = [];\r\n                let mechanism;\r\n                do {\r\n                    mechanism = this.reader.cstring();\r\n                    if (mechanism) {\r\n                        message.mechanisms.push(mechanism);\r\n                    }\r\n                } while (mechanism);\r\n                break;\r\n            case 11: // AuthenticationSASLContinue\r\n                message.name = 'authenticationSASLContinue';\r\n                message.data = this.reader.string(length - 8);\r\n                break;\r\n            case 12: // AuthenticationSASLFinal\r\n                message.name = 'authenticationSASLFinal';\r\n                message.data = this.reader.string(length - 8);\r\n                break;\r\n            default:\r\n                throw new Error('Unknown authenticationOk message type ' + code);\r\n        }\r\n        return message;\r\n    }\r\n    parseErrorMessage(offset, length, bytes, name) {\r\n        this.reader.setBuffer(offset, bytes);\r\n        const fields = {};\r\n        let fieldType = this.reader.string(1);\r\n        while (fieldType !== '\\0') {\r\n            fields[fieldType] = this.reader.cstring();\r\n            fieldType = this.reader.string(1);\r\n        }\r\n        const messageValue = fields.M;\r\n        const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\r\n        message.severity = fields.S;\r\n        message.code = fields.C;\r\n        message.detail = fields.D;\r\n        message.hint = fields.H;\r\n        message.position = fields.P;\r\n        message.internalPosition = fields.p;\r\n        message.internalQuery = fields.q;\r\n        message.where = fields.W;\r\n        message.schema = fields.s;\r\n        message.table = fields.t;\r\n        message.column = fields.c;\r\n        message.dataType = fields.d;\r\n        message.constraint = fields.n;\r\n        message.file = fields.F;\r\n        message.line = fields.L;\r\n        message.routine = fields.R;\r\n        return message;\r\n    }\r\n}\r\nexports.Parser = Parser;\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"script"}